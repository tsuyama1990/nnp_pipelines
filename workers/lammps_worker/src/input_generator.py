"""LAMMPS Input Generator.

Responsible for creating LAMMPS input scripts.
"""

from typing import Dict, List
import numpy as np

class LAMMPSInputGenerator:
    """Responsible for generating LAMMPS input scripts."""

    def __init__(self, lj_params: dict, md_params: dict, delta_learning_mode: bool = True):
        self.lj_params = lj_params
        self.md_params = md_params
        self.delta_learning_mode = delta_learning_mode

    def generate(
        self,
        filepath: str,
        potential_path: str,
        steps: int,
        gamma_threshold: float,
        input_structure: str,
        is_restart: bool,
    ) -> None:
        """Generates the LAMMPS input script."""
        template_path = self.md_params.get("input_template_path")

        if template_path:
            self._generate_from_template(
                filepath,
                template_path,
                potential_path,
                steps,
                gamma_threshold,
                input_structure,
                is_restart
            )
        else:
            self._generate_default(
                filepath,
                potential_path,
                steps,
                gamma_threshold,
                input_structure,
                is_restart
            )

    def _generate_from_template(
        self,
        filepath: str,
        template_path: str,
        potential_path: str,
        steps: int,
        gamma_threshold: float,
        input_structure: str,
        is_restart: bool,
    ) -> None:
        """Generates LAMMPS input using a user-provided template."""

        temp = self.md_params.get("temperature", 300.0)
        press = self.md_params.get("pressure", 1.0)
        is_restart_int = 1 if is_restart else 0

        # Read template
        with open(template_path, "r") as f:
            template_content = f.read()

        lines = [
            "# Generated by LAMMPSInputGenerator using template",
            f"variable structure_file string {input_structure}",
            f"variable potential_file string {potential_path}",
            f"variable n_steps equal {steps}",
            f"variable temp equal {temp}",
            f"variable press equal {press}",
            f"variable gamma_threshold equal {gamma_threshold}",
            f"variable is_restart equal {is_restart_int}",
            "",
            "# User Template Body",
            template_content
        ]

        with open(filepath, "w") as f:
            f.write("\n".join(lines))

    def _generate_default(
        self,
        filepath: str,
        potential_path: str,
        steps: int,
        gamma_threshold: float,
        input_structure: str,
        is_restart: bool,
    ) -> None:
        """Generates the default LAMMPS input script."""

        # Extract parameters
        epsilon = self.lj_params.get("epsilon", 1.0)
        sigma = self.lj_params.get("sigma", 1.0)
        rcut = self.lj_params.get("cutoff", 2.5)
        shift_energy = self.lj_params.get("shift_energy", True) # Default to True for safety

        elements = self.md_params.get("elements", [])
        element_map = " ".join(elements)

        timestep = self.md_params.get("timestep", 0.001)
        temp = self.md_params.get("temperature", 300.0)
        press = self.md_params.get("pressure", 1.0)
        restart_freq = self.md_params.get("restart_freq", 1000)
        dump_freq = self.md_params.get("dump_freq", 1000)
        masses = self.md_params.get("masses", {})

        lines = [
            "# ACE Active Carver MD Simulation",
            "units metal",
            "atom_style atomic",
            "boundary p p p",
        ]

        if is_restart:
            lines.append(f"read_restart {input_structure}")
        else:
            lines.append(f"read_data {input_structure}")

        # Dynamic mass setting
        for i, el in enumerate(elements):
            # Raise KeyError if mass is missing to prevent physical errors
            mass = masses[el]
            lines.append(f"mass {i+1} {mass}")

        # Pair style
        if potential_path and potential_path.lower() != "none":
            if self.delta_learning_mode:
                lines.append(f"pair_style hybrid/overlay pace/extrapolation lj/cut {rcut}")
                lines.append(f"pair_coeff * * pace/extrapolation {potential_path} {element_map}")
                self._write_lj_coeffs(lines, elements, epsilon, sigma, is_hybrid=True)
            else:
                lines.append("pair_style pace/extrapolation")
                lines.append(f"pair_coeff * * {potential_path} {element_map}")
        else:
            # Pure LJ mode (Seed Generation)
            lines.append(f"pair_style lj/cut {rcut}")
            self._write_lj_coeffs(lines, elements, epsilon, sigma, is_hybrid=False)

        # Enforce consistency with Python side ShiftedLennardJones
        # Only apply shift if LJ is being used (Delta Learning ON or Pure LJ)
        if (potential_path is None or potential_path.lower() == "none") or self.delta_learning_mode:
            if shift_energy:
                lines.append("pair_modify shift yes")
            else:
                lines.append("pair_modify shift no")

        lines.append("neighbor 1.0 bin")
        lines.append("neigh_modify delay 0 every 1 check yes")
        lines.append(f"timestep {timestep}")
        lines.append("thermo 10")
        lines.append("thermo_style custom step temp press pe ke etotal")

        # NPT fix
        lines.append(f"fix 1 all npt temp {temp} {temp} 0.1 iso {press} {press} 1.0")

        if potential_path and potential_path.lower() != "none":
            # Uncertainty monitoring
            lines.append("# Gamma calculation fix")
            lines.append("fix f_gamma all pair 10 pace/extrapolation gamma 1")
            lines.append("compute c_max_gamma all reduce max f_f_gamma")
            lines.append("variable v_max_gamma equal c_max_gamma")
            lines.append(f"fix halt_sim all halt 10 v_max_gamma > {gamma_threshold} error continue")
        else:
            # No gamma calculation in LJ mode
            lines.append("# No gamma monitoring in LJ mode")

        # Restart and Dump
        lines.append(f"restart {restart_freq} restart.chk")

        if potential_path and potential_path.lower() != "none":
            # We dump f_f_gamma to track uncertainty
            lines.append(f"dump 1 all custom {dump_freq} dump.lammpstrj id type x y z fx fy fz f_f_gamma")
        else:
            # Regular dump without gamma
            lines.append(f"dump 1 all custom {dump_freq} dump.lammpstrj id type x y z fx fy fz")

        lines.append(f"run {steps}")

        with open(filepath, "w") as f:
            f.write("\n".join(lines))

    def _write_lj_coeffs(self, lines: list, elements: list, epsilon, sigma, is_hybrid: bool):
        """Writes pair_coeff lines handling both scalar and dictionary parameters."""

        # Check if parameters are dictionaries
        is_dict_eps = isinstance(epsilon, dict)
        is_dict_sig = isinstance(sigma, dict)

        if is_dict_eps != is_dict_sig:
             # This should ideally not happen if validated, but let's fallback to scalar if mixed or raise error.
             # Assuming if one is dict, other should be too.
             pass

        if is_dict_eps and is_dict_sig:
            # Iterate over all unique pairs
            n = len(elements)
            for i in range(n):
                for j in range(i, n):
                    el_i = elements[i]
                    el_j = elements[j]

                    eps_i = epsilon[el_i]
                    eps_j = epsilon[el_j]
                    sig_i = sigma[el_i]
                    sig_j = sigma[el_j]

                    # Mixing rules
                    eps_ij = np.sqrt(eps_i * eps_j)
                    sig_ij = (sig_i + sig_j) / 2.0

                    # Type indices are 1-based
                    type_i = i + 1
                    type_j = j + 1

                    if is_hybrid:
                        lines.append(f"pair_coeff {type_i} {type_j} lj/cut {eps_ij} {sig_ij}")
                    else:
                        lines.append(f"pair_coeff {type_i} {type_j} {eps_ij} {sig_ij}")
        else:
            # Fallback to wildcard
            if is_hybrid:
                 lines.append(f"pair_coeff * * lj/cut {epsilon} {sigma}")
            else:
                 lines.append(f"pair_coeff * * {epsilon} {sigma}")
